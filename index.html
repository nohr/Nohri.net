<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <title>nohri</title>
  <meta name="description" content="">
  <meta name="author" content="nohri">
  <link rel="stylesheet" href="index.css">
  <script src="blotter.min.js"></script>
  <script src="fliesMaterial.js"></script>
</head>
<body>
  <!--Blotter-->
  <script>
    var text = new Blotter.Text("nohri", {
      family : "serif",
      size : 120,
      fill : "#171717"
    });

    var material = new Blotter.FliesMaterial();

    var blotter = new Blotter(material, { texts : text });

    var scope = blotter.forText(text);

    scope.appendTo(document.body);
  </script>
    <!-- div that will hold our WebGL canvas -->
    <div id="canvas"></div>
    <!-- div used to create our plane -->
    <div class="curtain" id="main-curtain" data-vs-id="plane-vs" data-fs-id="plane-fs">
      <!-- image that will be used as a texture by our plane -->
      <video src="IMG_6012.mp4" preload="true" data-sampler="simplePlaneVideoTexture" loop autoplay>
          Your browser does not support the video tag.
      </video>
    </div>

    <div id="enter-site"></div>
  <script src="curtains.js"></script>
  <script src="index.js"></script>
<script id="plane-vs" type="x-shader/x-vertex">
  #ifdef GL_ES
  precision mediump float;
  #endif

  // those are the mandatory attributes that the lib sets
  attribute vec3 aVertexPosition;
  attribute vec2 aTextureCoord;

  // those are mandatory uniforms that the lib sets and that contain our model view and projection matrix
  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;
  
  // texture matrix
  uniform mat4 simplePlaneVideoTextureMatrix;

  // our time uniform
  uniform float uTime;

  // our mouse position uniform
  uniform vec2 uMousePosition;

  // our mouse strength
  uniform float uMouseStrength;

  // if you want to pass your vertex and texture coords to the fragment shader
  varying vec3 vVertexPosition;
  varying vec2 vTextureCoord;

  void main() {
    vec3 vertexPosition = aVertexPosition;

    // get the distance between our vertex and the mouse position
    float distanceFromMouse = distance(uMousePosition, vec2(vertexPosition.x, vertexPosition.y));

    // this will define how close the ripples will be from each other. The bigger the number, the more ripples you'll get
    float rippleFactor = 4.0;
    // calculate our ripple effect
    float rippleEffect = cos(rippleFactor * (distanceFromMouse - (uTime / 60.0)));

    // calculate our distortion effect
    float distortionEffect = rippleEffect * uMouseStrength;

    // apply it to our vertex position
    vertexPosition +=  distortionEffect / 15.0;

       gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0);

    // varyings
       vTextureCoord = (simplePlaneVideoTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;
       vVertexPosition = vertexPosition;
  }
  </script>
<script id="plane-fs" type="x-shader/x-fragment">
  #ifdef GL_ES
  precision mediump float;
  #endif

  // get our varyings
  varying vec3 vVertexPosition;
  varying vec2 vTextureCoord;

  // our texture sampler (this is the lib default name, but it could be changed)
  uniform sampler2D simplePlaneVideoTexture;

  void main() {
    // get our texture coords
    vec2 textureCoords = vTextureCoord;

    // apply our texture
    vec4 finalColor = texture2D(simplePlaneVideoTexture, textureCoords);

    // fake shadows based on vertex position along Z axis
    finalColor.rgb -= clamp(-vVertexPosition.z, 0.0, 1.0);
    // fake lights based on vertex position along Z axis
    finalColor.rgb += clamp(vVertexPosition.z, 0.0, 1.0);

    // handling premultiplied alpha (useful if we were using a png with transparency)
    finalColor = vec4(finalColor.rgb * finalColor.a, finalColor.a);

    gl_FragColor = finalColor;
  }
  </script>
</body>
</html>